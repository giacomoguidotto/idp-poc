# Ideas

> **Guiding principle**: Is it possible to *not* use a navbar item for this feature?
> Navbar is acceptable only for "customizing the experience" — but not encouraged.

---

## I1 — Version Control / Timeline + Relive Event

> **TL;DR**: A floating, draggable timeline that shows system events. Click an event to enter a historical snapshot. Relive mode replays traces step-by-step with animated dots traveling the request path.

A draggable floating timeline panel accessible from a small button at the bottom of the viewport (icon: timeline/clock). Hovering the button expands it into a full timeline bar taking the bottom space. The bar is freely draggable anywhere on the viewport (unconstrained, like a pen-tool bar in note-taking apps). The timeline displays all system events: bugs, deployments, proposals. Hovering the edges of the timeline reveals a "search backwards" affordance; clicking moves the time range. Hovering an event shows a minimal tooltip. Clicking an event transitions the entire canvas into a historical snapshot of that moment — highlighting the event similarly to the tracing layer — and the timeline collapses back to button mode with an exit button beside it. Reopening the timeline while in snapshot mode also shows the exit button. Exiting snapshot mode returns the canvas to "live" state. "Live" replaces "tracing" as the default active layer.

### Relive mode

When entering a snapshot for a traceable event (e.g. "place order"), the timeline doesn't just highlight affected components statically — it replays the event step-by-step. Edges light up sequentially following the actual request path (Gateway → Order Service → Payment Service → Notification Service), with a small animated dot traveling each hop. The timeline scrubber tracks the current step; dragging it moves forward/backward through the trace. Each step shows latency and status in a minimal overlay on the active edge. This turns the snapshot from a static highlight into a spatial, animated re-enactment of the request flow.

---

## I2 — Repo Introspection

> **TL;DR**: LLM inspects and understands repo structure, mapping features and connections automatically.

Using LLM to inspect and understand repo structure, with features and connections.

---

## I3 — RBAC

> **TL;DR**: Permissions configured through a meta-canvas — platform functions become spatial nodes, teams/roles are listed per-function. No settings tables.

Configuration happens through a **meta-canvas** — a dedicated spatial view that unpacks the platform's own functions into interactive elements. Every controllable surface in the UI becomes a button on this canvas. For example, the three layers from the top-left panel (Live, Building, Platform) each appear as a node; clicking one reveals a list of all teams/roles and their access level for that layer (view, edit, none). Same principle extends to other functions: timeline access, building toolbar actions (add/delete/connect nodes), runbook actions, environment switching, etc.

The meta-canvas approach keeps RBAC consistent with the product's spatial philosophy — you configure permissions the same way you navigate the system: by clicking things on a canvas, not by filling out a table in a settings page. Each "function node" on the meta-canvas could show a small badge with the count of teams that have access, and expanding it reveals the full permission matrix for that function.

### Sanity check

- Scales well for small-to-medium orgs (< 20 teams). For larger orgs, grouping function-nodes by category (layers, actions, data) prevents clutter.
- The meta-canvas itself needs RBAC — only admins should see it. A simple "Admin" entry in the header dropdown (acceptable navbar use per the minimal UI rule since this is "customizing the experience").
- Edge case: cross-cutting permissions (e.g. "read-only everywhere") should be expressible as a role template that can be dragged onto multiple function-nodes at once, not configured one by one.

---

## I4 — Semantic Zoom

> **TL;DR**: Zoom into a node to reveal its internals — features as sub-nodes, individual Kafka topics between services, etc.

Enter the details of a node just by zooming into it. Create a small cue at a certain zoom level to suggest that the node is about to expand, also following the cursor position (two components in the screen, follow the one where the cursor is hovering at, block if none). If continued zooming, the node will expand showing the details. For example showing the features as smaller nodes inside the microservice, or showing the singular kafka topics between two microservices that has more than one.

---

## I5 — DevOps View

> **TL;DR**: Full Kubernetes cluster visibility in the Platform layer.

In the Infra layer, be able to see everything of the cluster, like namespaces, pods, kubelet etc.

---

## I6 — Universal Search

> **TL;DR**: `cmd+k` to search anything across the entire platform.

Self-explanatory. `cmd+k` and be able to search ANYTHING.

---

## I7 — Multi-collaboration

> **TL;DR**: Real-time multi-user canvas editing with integrated chat.

Multiple users, collaborating in real-time. Implement a chat feature to facilitate communication and collaboration among team members.

---

## I8 — Env Stacking (Diff between envs)

> **TL;DR**: Environments stacked on the z-axis like glass panes. Scroll to switch, pinch to pull apart. Diff markers highlight what changed. Quick-diff mode overlays all envs simultaneously.

Components are the same, environments change. The challenge: how to make differences instantly visible without tab-switching or side-by-side layouts that break the spatial mental model.

### Z-axis stacking

Environments are rendered as the same canvas stacked along the z-axis — like transparent layers in Photoshop or glass panes in physical space. The active environment sits at z=0 (full opacity, interactive). Other environments float behind it at increasing z-depth, slightly scaled down and faded (e.g. staging at z=-1 with 40% opacity, dev at z=-2 with 20%). A subtle parallax shift on mouse movement reinforces the depth illusion.

### Diff highlighting

Nodes/edges that differ between the foreground env and any background env get a visual diff marker — a colored outline or glow (green = only in foreground, red = only in background, amber = present in both but different config/version). Hovering a diff-marked node shows a compact comparison tooltip (e.g. "prod: v2.3.1 / staging: v2.4.0-rc1, 2 replicas vs 3 replicas").

### Interaction

Scroll-wheel on a dedicated axis control (or a small depth slider on the side) brings a background env forward to z=0, pushing the current one back. This feels like flipping through stacked cards. Pinching (trackpad) could also map to the z-axis for a natural "pull apart the stack" gesture. The transition animates smoothly — the canvases slide past each other with a slight blur during motion.

### Quick diff mode

A toggle that collapses all environments to z=0 simultaneously, overlaying them with maximum transparency. Only the differences remain visible (identical nodes cancel out to solid, differences shimmer). This is the "instant answer" mode — glance and see every delta across all envs at once.

---

## I9 — Kargo Plugin

> **TL;DR**: Autopromote or schedule service promotions, useful when inspecting env diffs.

Autopromote or schedule autopromotions services, useful when inspecting the diff between envs.

---

## I10 — Blast Radius Simulation

> **TL;DR**: Click a node, trigger "what if this dies?" — animated domino-effect cascades through the dependency graph with an impact summary.

Click any node and trigger a "what if this dies?" mode. Animated domino-effect cascades through dependent services — edges flash red sequentially following the dependency graph, downstream nodes dim one by one with a staggered delay. A small overlay tallies the blast: "4 services affected, ~12k users impacted." Inverts the typical post-mortem into a pre-mortem tool.

---

## I11 — Cost Flow Layer

> **TL;DR**: Edge thickness = dollar cost. Nodes show monthly spend as radial fill. See where the money goes without opening a billing console.

A fourth layer (or sub-layer of Platform) where edge thickness represents dollar cost. Cloud spend flows visually through the graph like water — thick, bright edges are expensive paths, thin ones are cheap. Nodes show their monthly cost as a radial fill. Immediately answers "where is our money going?" without opening a billing console. Pairs naturally with env diff (I8).

---

## I12 — Ambient Sonification

> **TL;DR**: System health mapped to generative audio. Hear degradation before seeing it.

Map system health to generative audio. Healthy = low warm drone, degraded = subtle dissonance, critical = percussive alert tones. Each node contributes a voice to the mix based on its metrics. Engineers can "listen" to their system in the background while coding — a degradation in the soundscape triggers attention before any dashboard. Toggle on/off from the header.

---

## I13 — Canvas Annotations / Sketch Layer

> **TL;DR**: Freeform drawing on the canvas (pen, arrows, stickies). Persisted per-layer and per-snapshot. Searchable, timestamped, attributed.

A freeform drawing layer over the canvas — pen strokes, arrows, text boxes, sticky notes. Persisted per-layer and per-snapshot. During incident reviews, draw directly on the affected path. During architecture discussions, sketch proposed changes on top of the live topology. Annotations are first-class objects: searchable, timestamped, attributable to a user.

---

## I14 — Spatial Bookmarks (Viewpoints)

> **TL;DR**: Save camera + layer + focus + timeline position as a named viewpoint. Jump instantly. Share as deep links.

Save the current camera position + layer + focus state + timeline position as a named "viewpoint." Jump between viewpoints instantly. Share them as deep links. Use cases: "Payment debug view" (zoomed into payment cluster, live layer, focus on Payment Service), "Sprint 12 proposals" (building layer, zoomed out, timeline at proposal date). Essentially browser bookmarks for the system's spatial state.

---

## I15 — AI Narrator (System Storytelling)

> **TL;DR**: LLM watches metrics and generates a running narrative. Click any sentence to navigate to the relevant nodes/edges.

An LLM watches the metric stream and generates a running natural-language narrative in a small aside panel: "Order Service latency spiked 3x following the Payment Service deploy at 14:15. The spike correlates with the new retry policy — see edge Order→Payment for details." Click any sentence and the canvas navigates to the relevant nodes/edges. Turns raw metrics into a readable incident log. Pairs with timeline (I1) and relive mode.

---

## I16 — Ownership Territories

> **TL;DR**: Convex hulls colored by team ownership. See boundaries, cross-team dependencies, and orphaned services at a glance.

Color-fill convex hulls around node clusters by team ownership. The canvas becomes a territory map — you instantly see team boundaries, shared dependencies crossing territory lines, and orphaned services with no owner. Hovering a territory highlights all its edges (internal = solid, cross-team = dashed).

---

## I17 — Runbook Actions (Canvas as Control Plane)

> **TL;DR**: Right-click a node for actions (restart, scale, deploy, rollback). RBAC-gated, blast-radius-aware. The canvas becomes a control surface.

Right-click a node → contextual actions: restart pod, scale replicas, toggle feature flag, trigger deploy, rollback. The canvas isn't just a viewer — it's a control surface. Actions are gated by RBAC (I3) and produce timeline events (I1). Confirmation dialogs show blast radius (I10). Collapses the observe→decide→act loop into a single spatial interface.

---

## I18 — Project List (Canvas of Canvases)

> **TL;DR**: Zoom out past a threshold to see all projects as live-thumbnail tiles. Zoom into any tile to enter that project. Google Maps-style semantic zoom.

Each project is a canvas. The question: how do you navigate between them?

### Zoom-out transition

From within a project canvas, zooming out past a threshold (e.g. below 0.15x zoom) triggers a smooth transition to a grid view where each project appears as a miniaturized, live-thumbnail canvas tile. The tiles show a simplified rendering of the topology (just node dots and edge lines, no labels) with a health-status glow (green/amber/red border). Zooming into any tile transitions back into that project's full canvas.

### UX considerations

- The zoom-out approach is natural for spatial interfaces (Google Maps does this — zoom out from street to city to country) and consistent with I4's semantic zoom philosophy.
- Risk: accidental zoom-out. Mitigate with a clear "threshold zone" — at ~0.2x zoom, show a subtle vignette or label ("zoom out more to see all projects") so the user knows they're approaching the transition, and can stop if unintentional.
- Alternative entry: `cmd+P` or a small "projects" icon in the header for keyboard-first users who don't want to zoom-dance.
- Each tile could show a one-line status summary (e.g. "3 critical, 1 deploying") and the project name.
- The grid itself could be spatial — projects that share infrastructure or teams are placed closer together, creating an org-level topology.
